"""Dependency vulnerability scanning tests.

This module tests automated vulnerability scanning of project dependencies
using tools like Safety and Bandit.
"""

import asyncio
import json
import os
import subprocess
import sys
import time
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

import httpx
import pytest


@pytest.mark.security
@pytest.mark.vulnerability
class TestDependencyScanning:
    """Test dependency vulnerability scanning."""

    @pytest.fixture
    def project_root(self):
        """Get project root directory."""
        return Path(__file__).parent.parent.parent.parent

    @pytest.fixture
    def requirements_files(self, project_root):
        """Get requirements files."""
        return {
            "requirements.txt": project_root / "requirements.txt",
            "requirements-dev.txt": project_root / "requirements-dev.txt",
            "pyproject.toml": project_root / "pyproject.toml",
        }

    @pytest.fixture
    def mock_vulnerability_database(self):
        """Mock vulnerability database for testing."""
        return {
            "vulnerabilities": [
                {
                    "id": "CVE-2023-0001",
                    "package": "vulnerable-package",
                    "versions": ["<1.2.3"],
                    "severity": "high",
                    "description": "SQL injection vulnerability",
                    "cwe": "CWE-89",
                    "cvss_score": 8.5,
                    "fixed_in": "1.2.3",
                },
                {
                    "id": "CVE-2023-0002",
                    "package": "another-vulnerable-package",
                    "versions": [">=1.0.0,<2.1.0"],
                    "severity": "medium",
                    "description": "Cross-site scripting vulnerability",
                    "cwe": "CWE-79",
                    "cvss_score": 6.1,
                    "fixed_in": "2.1.0",
                },
                {
                    "id": "CVE-2023-0003",
                    "package": "insecure-crypto",
                    "versions": ["<=3.0.0"],
                    "severity": "critical",
                    "description": "Weak cryptographic implementation",
                    "cwe": "CWE-327",
                    "cvss_score": 9.8,
                    "fixed_in": "3.1.0",
                },
            ]
        }

    @pytest.fixture
    def safety_scanner(self, mock_vulnerability_database):
        """Mock Safety vulnerability scanner."""

        class SafetyScanner:
            def __init__(self, vuln_db):
                self.vuln_db = vuln_db

            def scan_requirements(self, requirements_file: str) -> list[dict[str, Any]]:
                """Scan requirements file for vulnerabilities."""
                # Parse requirements file (simplified)
                packages = self._parse_requirements(requirements_file)
                vulnerabilities = []

                for package_name, version in packages.items():
                    vulnerabilities.extend(
                        [
                            {
                                "package": package_name,
                                "installed_version": version,
                                "vulnerability": vuln,
                            }
                            for vuln in self.vuln_db["vulnerabilities"]
                            if vuln["package"] == package_name
                            and self._version_is_vulnerable(version, vuln["versions"])
                        ]
                    )

                return vulnerabilities

            def _parse_requirements(self, _requirements_file: str) -> dict[str, str]:
                """Parse requirements file (simplified)."""
                # This would parse actual requirements in real implementation
                return {
                    "vulnerable-package": "1.2.0",  # Vulnerable version
                    "safe-package": "2.0.0",
                    "another-vulnerable-package": "1.5.0",  # Vulnerable version
                }

            def _version_is_vulnerable(
                self, version: str, vulnerable_versions: list[str]
            ) -> bool:
                """Check if version is vulnerable (simplified)."""
                # Simplified version checking - real implementation would use packaging.version
                for vuln_version in vulnerable_versions:
                    if "<" in vuln_version:
                        max_version = vuln_version.replace("<", "")
                        if version < max_version:
                            return True
                    elif "=" in vuln_version and "," in vuln_version:
                        # Range check (simplified)
                        return True
                return False

        return SafetyScanner(mock_vulnerability_database)

    @pytest.fixture
    def bandit_scanner(self):
        """Mock Bandit security scanner."""

        class BanditScanner:
            def __init__(self):
                self.test_results = []

            def scan_code(self, _source_paths: list[str]) -> dict[str, Any]:
                """Scan source code for security issues."""
                return {
                    "results": [
                        {
                            "filename": "src/example.py",
                            "test_name": "hardcoded_password_string",
                            "test_id": "B106",
                            "issue_severity": "LOW",
                            "issue_confidence": "MEDIUM",
                            "line_number": 45,
                            "line_range": [45],
                            "code": "password = 'hardcoded_secret'",
                            "issue_text": "Possible hardcoded password: 'hardcoded_secret'",
                        },
                        {
                            "filename": "src/database.py",
                            "test_name": "sql_injection_risk",
                            "test_id": "B608",
                            "issue_severity": "HIGH",
                            "issue_confidence": "HIGH",
                            "line_number": 123,
                            "line_range": [123, 124],
                            "code": "cursor.execute(f'SELECT * FROM users WHERE id = {user_id}')",
                            "issue_text": "Possible SQL injection vector through string-based query construction",
                        },
                    ],
                    "metrics": {
                        "__totals": {
                            "SEVERITY.HIGH": 1,
                            "SEVERITY.MEDIUM": 0,
                            "SEVERITY.LOW": 1,
                            "CONFIDENCE.HIGH": 1,
                            "CONFIDENCE.MEDIUM": 1,
                            "CONFIDENCE.LOW": 0,
                        }
                    },
                }

        return BanditScanner()

    def test_safety_dependency_scan(self, safety_scanner):
        """Test Safety dependency vulnerability scanning."""
        vulnerabilities = safety_scanner.scan_requirements("requirements.txt")

        # Should find vulnerabilities in test data
        assert len(vulnerabilities) > 0

        # Check vulnerability structure
        for vuln in vulnerabilities:
            assert "package" in vuln
            assert "installed_version" in vuln
            assert "vulnerability" in vuln
            assert "id" in vuln["vulnerability"]
            assert "severity" in vuln["vulnerability"]
            assert "description" in vuln["vulnerability"]

    def test_safety_critical_vulnerability_detection(self, safety_scanner):
        """Test detection of critical vulnerabilities."""
        vulnerabilities = safety_scanner.scan_requirements("requirements.txt")

        critical_vulns = [
            v for v in vulnerabilities if v["vulnerability"]["severity"] == "critical"
        ]

        # Should detect critical vulnerabilities
        assert len(critical_vulns) > 0

        for vuln in critical_vulns:
            assert vuln["vulnerability"]["cvss_score"] >= 9.0

    def test_safety_high_severity_vulnerability_detection(self, safety_scanner):
        """Test detection of high severity vulnerabilities."""
        vulnerabilities = safety_scanner.scan_requirements("requirements.txt")

        high_severity_vulns = [
            v
            for v in vulnerabilities
            if v["vulnerability"]["severity"] in ["high", "critical"]
        ]

        # Should detect high severity vulnerabilities
        assert len(high_severity_vulns) > 0

        for vuln in high_severity_vulns:
            assert vuln["vulnerability"]["cvss_score"] >= 7.0

    def test_bandit_code_security_scan(self, bandit_scanner):
        """Test Bandit code security scanning."""
        scan_results = bandit_scanner.scan_code(["src/"])

        # Should have scan results
        assert "results" in scan_results
        assert "metrics" in scan_results

        # Check for security issues
        results = scan_results["results"]
        assert len(results) > 0

        # Verify issue structure
        for issue in results:
            assert "filename" in issue
            assert "test_name" in issue
            assert "test_id" in issue
            assert "issue_severity" in issue
            assert "issue_confidence" in issue
            assert "line_number" in issue
            assert "code" in issue
            assert "issue_text" in issue

    def test_bandit_high_severity_detection(self, bandit_scanner):
        """Test Bandit detection of high severity issues."""
        scan_results = bandit_scanner.scan_code(["src/"])

        high_severity_issues = [
            issue
            for issue in scan_results["results"]
            if issue["issue_severity"] == "HIGH"
        ]

        # Should detect high severity issues
        assert len(high_severity_issues) > 0

        for issue in high_severity_issues:
            assert issue["issue_confidence"] in ["HIGH", "MEDIUM"]

    @pytest.mark.asyncio
    async def test_vulnerability_scan_integration(self, project_root):
        """Test integration with actual vulnerability scanning tools."""
        # Use real vulnerability scanning APIs
        scan_results = {}

        # 1. Real Safety scanning
        try:
            safety_scanner = await self._create_real_safety_scanner()
            safety_results = await safety_scanner.scan_project(project_root)
            scan_results["safety"] = safety_results

            # Validate real vulnerability data structure
            assert isinstance(safety_results, list)
            for vuln in safety_results:
                assert "vulnerability_id" in vuln
                assert "package_name" in vuln
                assert "installed_version" in vuln
                assert "affected_versions" in vuln
                assert "severity" in vuln

        except (ValueError, TypeError, AttributeError) as e:
            pytest.skip(f"Safety scanning not available: {e}")

        # 2. Real OSVI (Open Source Vulnerability Index) integration
        try:
            osvi_scanner = await self._create_osvi_scanner()
            osvi_results = await osvi_scanner.scan_dependencies(project_root)
            scan_results["osvi"] = osvi_results

            # Validate OSVI results
            assert isinstance(osvi_results, dict)
            assert "vulnerabilities" in osvi_results
            assert "scan_timestamp" in osvi_results

        except (asyncio.CancelledError, TimeoutError, RuntimeError) as e:
            pytest.skip(f"OSVI scanning not available: {e}")

        # 3. GitHub Security Advisory integration
        try:
            github_scanner = await self._create_github_advisory_scanner()
            github_results = await github_scanner.scan_project(project_root)
            scan_results["github_advisories"] = github_results

        except (asyncio.CancelledError, TimeoutError, RuntimeError) as e:
            pytest.skip(f"GitHub Advisory scanning not available: {e}")

        # 4. Snyk integration (if API key available)
        if os.getenv("SNYK_TOKEN"):
            try:
                snyk_scanner = await self._create_snyk_scanner()
                snyk_results = await snyk_scanner.scan_project(project_root)
                scan_results["snyk"] = snyk_results

            except (asyncio.CancelledError, TimeoutError, RuntimeError) as e:
                print(f"Snyk scanning failed: {e}")

        # Aggregate and analyze real scan results
        critical_vulns = self._aggregate_critical_vulnerabilities(scan_results)

        # Real security policy enforcement
        if critical_vulns:
            self._enforce_security_policy(critical_vulns)

        # Store scan results for CI/CD integration
        await self._store_scan_results(scan_results, project_root)

    async def _create_real_safety_scanner(self):
        """Create real Safety scanner with API integration."""

        class RealSafetyScanner:
            def __init__(self):
                self.client = None
                self.api_url = "https://pyup.io/api/v1/safety/"

            async def scan_project(self, project_root: Path) -> list[dict]:
                """Scan project using real Safety API."""
                requirements_files = [
                    project_root / "requirements.txt",
                    project_root / "requirements-dev.txt",
                    project_root / "pyproject.toml",
                ]

                vulnerabilities = []

                for req_file in requirements_files:
                    if req_file.exists():
                        try:
                            proc = await asyncio.create_subprocess_exec(
                                sys.executable,
                                "-m",
                                "safety",
                                "check",
                                "--json",
                                "--file",
                                str(req_file),
                                cwd=project_root,
                                stdout=asyncio.subprocess.PIPE,
                                stderr=asyncio.subprocess.PIPE,
                            )
                            stdout, _stderr = await asyncio.wait_for(
                                proc.communicate(), timeout=60
                            )

                            if stdout:
                                safety_data = json.loads(stdout.decode())
                                vulnerabilities.extend(safety_data)

                        except (TimeoutError, json.JSONDecodeError) as e:
                            print(f"Safety scan failed for {req_file}: {e}")

                return vulnerabilities

        return RealSafetyScanner()

    async def _create_osvi_scanner(self):
        """Create real OSVI scanner integration."""

        class OSVIScanner:
            def __init__(self):
                self.client = None
                self.api_url = "https://api.osv.dev/v1/"

            async def scan_dependencies(self, project_root: Path) -> dict:
                """Scan dependencies using OSV API."""
                vulnerabilities = []
                packages = await self._extract_installed_packages(project_root)

                for package_name, version in packages.items():
                    try:
                        response = await self.client.post(
                            f"{self.api_url}query",
                            json={
                                "package": {"name": package_name, "ecosystem": "PyPI"},
                                "version": version,
                            },
                        )

                        if response.status_code == 200:
                            data = response.json()
                            if "vulns" in data:
                                vulnerabilities.extend(
                                    [
                                        {
                                            "vulnerability_id": vuln["id"],
                                            "package_name": package_name,
                                            "installed_version": version,
                                            "severity": vuln.get(
                                                "database_specific", {}
                                            ).get("severity", "UNKNOWN"),
                                            "summary": vuln.get("summary", ""),
                                            "details": vuln.get("details", ""),
                                            "references": vuln.get("references", []),
                                        }
                                        for vuln in data["vulns"]
                                    ]
                                )

                    except (
                        ConnectionError,
                        TimeoutError,
                        RuntimeError,
                    ) as e:
                        print(f"OSV scan failed for {package_name}: {e}")

                return {
                    "vulnerabilities": vulnerabilities,
                    "scan_timestamp": time.time(),
                    "packages_scanned": len(packages),
                }

            async def _extract_installed_packages(
                self, project_root: Path
            ) -> dict[str, str]:
                """Extract installed packages and versions."""
                try:
                    proc = await asyncio.create_subprocess_exec(
                        sys.executable,
                        "-m",
                        "pip",
                        "list",
                        "--format=json",
                        cwd=project_root,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE,
                    )
                    stdout, _stderr = await asyncio.wait_for(
                        proc.communicate(), timeout=30
                    )

                    if proc.returncode == 0:
                        packages = json.loads(stdout.decode())
                        return {pkg["name"]: pkg["version"] for pkg in packages}

                except (json.JSONDecodeError, ValueError, TypeError) as e:
                    print(f"Failed to extract packages: {e}")

                return {}

        return OSVIScanner()

    async def _create_github_advisory_scanner(self):
        """Create GitHub Security Advisory scanner."""

        class GitHubAdvisoryScanner:
            def __init__(self):
                self.api_url = "https://api.github.com/advisories"

            async def scan_project(self, project_root: Path) -> dict:
                """Scan using GitHub Security Advisories."""
                packages = await self._extract_packages(project_root)
                advisories = []

                async with httpx.AsyncClient(timeout=60.0) as client:
                    for package_name in packages:
                        try:
                            response = await client.get(
                                self.api_url,
                                params={
                                    "ecosystem": "pip",
                                    "affects": package_name,
                                    "sort": "published",
                                    "direction": "desc",
                                },
                            )

                            if response.status_code == 200:
                                data = response.json()
                                advisories.extend(data)

                        except (json.JSONDecodeError, ValueError, TypeError) as e:
                            print(
                                f"GitHub Advisory scan failed for {package_name}: {e}"
                            )

                return {"advisories": advisories, "scan_timestamp": time.time()}

            async def _extract_packages(self, project_root: Path) -> list[str]:
                """Extract package names from project."""
                packages = set()

                # Parse requirements files
                req_files = [
                    project_root / "requirements.txt",
                    project_root / "requirements-dev.txt",
                ]

                for req_file in req_files:
                    if req_file.exists():
                        with req_file.open() as f:
                            for line in f:
                                stripped_line = line.strip()
                                if stripped_line and not stripped_line.startswith("#"):
                                    package_name = (
                                        stripped_line.split("==")[0]
                                        .split(">=")[0]
                                        .split("<=")[0]
                                    )
                                    packages.add(package_name)

                return list(packages)

        return GitHubAdvisoryScanner()

    async def _create_snyk_scanner(self):
        """Create Snyk scanner integration."""

        class SnykScanner:
            def __init__(self):
                self.client = httpx.AsyncClient(
                    headers={"Authorization": f"token {os.getenv('SNYK_TOKEN')}"},
                    timeout=120.0,
                )
                self.api_url = "https://snyk.io/api/v1/"

            async def scan_project(self, project_root: Path) -> dict:
                """Scan project using Snyk API."""
                try:
                    # Upload and scan project files
                    response = await self._upload_project_for_scan(project_root)

                    if response:
                        return await self._get_scan_results(response["scan_id"])

                except (OSError, FileNotFoundError, PermissionError) as e:
                    print(f"Snyk scan failed: {e}")

                return {"vulnerabilities": [], "scan_timestamp": time.time()}

            async def _upload_project_for_scan(self, project_root: Path) -> dict | None:
                """Upload project files to Snyk for scanning."""
                # Implementation would depend on Snyk API requirements
                # This is a simplified version
                return {"scan_id": "mock_scan_id"}

            async def _get_scan_results(self, scan_id: str) -> dict:
                """Get scan results from Snyk."""
                # Implementation would poll Snyk API for results
                return {"vulnerabilities": [], "scan_timestamp": time.time()}

        return SnykScanner()

    def _aggregate_critical_vulnerabilities(self, scan_results: dict) -> list[dict]:
        """Aggregate critical vulnerabilities from all scanners."""
        critical_vulns = []

        for scanner_name, results in scan_results.items():
            if scanner_name == "safety" and isinstance(results, list):
                critical_vulns.extend(
                    [
                        vuln
                        for vuln in results
                        if vuln.get("severity", "").lower() in ["critical", "high"]
                    ]
                )

            elif scanner_name == "osvi" and isinstance(results, dict):
                osvi_vulns = results.get("vulnerabilities", [])
                critical_vulns.extend(
                    [
                        vuln
                        for vuln in osvi_vulns
                        if vuln.get("severity", "").upper() in ["CRITICAL", "HIGH"]
                    ]
                )

            elif scanner_name == "github_advisories" and isinstance(results, dict):
                advisories = results.get("advisories", [])
                critical_vulns.extend(
                    [
                        advisory
                        for advisory in advisories
                        if advisory.get("severity", "").lower() in ["critical", "high"]
                    ]
                )

        return critical_vulns

    def _enforce_security_policy(self, critical_vulns: list[dict]):
        """Enforce security policy based on vulnerabilities found."""
        if not critical_vulns:
            return

        # Count critical vs high severity
        critical_count = sum(
            1 for v in critical_vulns if v.get("severity", "").lower() == "critical"
        )
        high_count = sum(
            1 for v in critical_vulns if v.get("severity", "").lower() == "high"
        )

        # Security policy enforcement
        if critical_count > 0:
            # Log critical vulnerabilities but don't fail in test environment
            print(f"SECURITY ALERT: {critical_count} critical vulnerabilities found")
            for vuln in critical_vulns:
                if vuln.get("severity", "").lower() == "critical":
                    package_name = vuln.get("package_name", "Unknown")
                    vuln_id = vuln.get("vulnerability_id", "Unknown ID")
                    print(f"  - {package_name}: {vuln_id}")

        if high_count > 5:  # Threshold for high severity vulnerabilities
            print(f"SECURITY WARNING: {high_count} high severity vulnerabilities found")

    async def _store_scan_results(self, scan_results: dict, project_root: Path):
        """Store scan results for CI/CD integration."""
        results_dir = project_root / ".security-scan-results"
        results_dir.mkdir(exist_ok=True)

        timestamp = datetime.now(UTC).isoformat()
        results_file = results_dir / f"scan-{timestamp}.json"

        with results_file.open("w") as f:
            json.dump(
                {
                    "timestamp": timestamp,
                    "scan_results": scan_results,
                    "summary": {
                        "total_vulnerabilities": sum(
                            len(results)
                            if isinstance(results, list)
                            else len(results.get("vulnerabilities", []))
                            if isinstance(results, dict)
                            else 0
                            for results in scan_results.values()
                        ),
                        "scanners_used": list(scan_results.keys()),
                    },
                },
                f,
                indent=2,
            )

    def test_bandit_integration(self, project_root):
        """Test integration with actual Bandit scanning."""
        try:
            # Validate Python executable for security
            if not sys.executable or not Path(sys.executable).is_file():
                pytest.skip("Python executable not found or invalid")

            # Test Bandit - explicitly construct command for security
            bandit_cmd = [sys.executable, "-m", "bandit", "-r", "src/", "-f", "json"]
            result = (
                subprocess.run(  # Secure: validated executable, no shell, no user input
                    bandit_cmd,
                    cwd=project_root,
                    capture_output=True,
                    text=True,
                    timeout=120,
                    check=False,
                )
            )

            # Bandit returns non-zero exit code when issues are found
            if result.stdout:
                try:
                    bandit_output = json.loads(result.stdout)
                    assert "results" in bandit_output
                    assert "metrics" in bandit_output

                    # Check for any HIGH severity issues
                    high_issues = [
                        issue
                        for issue in bandit_output["results"]
                        if issue.get("issue_severity") == "HIGH"
                    ]

                    # Log any high severity issues for review
                    if high_issues:
                        print(f"Found {len(high_issues)} high severity security issues")
                        for issue in high_issues:
                            print(
                                f"  {issue['filename']}:{issue['line_number']} - {issue['issue_text']}"
                            )

                except json.JSONDecodeError:
                    pytest.skip("Bandit output format not parseable")

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pytest.skip("Bandit tool not available or timed out")

    def test_dependency_pinning_security(self, requirements_files):
        """Test that dependencies are properly pinned for security."""
        for req_file_name, req_file_path in requirements_files.items():
            if req_file_path.exists():
                with req_file_path.open() as f:
                    content = f.read()

                if req_file_name.endswith(".txt"):
                    lines = [
                        line.strip()
                        for line in content.split("\n")
                        if line.strip() and not line.startswith("#")
                    ]

                    unpinned_packages = [
                        line
                        for line in lines
                        if "==" not in line and ">=" not in line and "~=" not in line
                        # Package is not pinned
                    ]

                    # Allow some flexibility but warn about completely unpinned packages
                    if unpinned_packages:
                        print(
                            f"Warning: Unpinned packages in {req_file_name}: {unpinned_packages}"
                        )

    def test_known_vulnerable_packages(self):
        """Test detection of known vulnerable packages."""
        known_vulnerable = [
            "jinja2<2.11.3",  # CVE-2020-28493
            "pillow<8.1.1",  # Multiple CVEs
            "django<3.1.6",  # CVE-2021-3281
            "flask<2.0.0",  # Multiple security issues
            "requests<2.25.0",  # CVE-2021-33503
        ]

        # In a real test, this would check actual installed packages
        # For demo purposes, we'll simulate the check
        def check_package_vulnerability(package_spec: str) -> bool:
            """Check if package specification represents a vulnerable version."""
            # This would integrate with actual vulnerability databases
            package_name = package_spec.split("<")[0]
            return package_name in ["jinja2", "pillow", "django", "flask", "requests"]

        for package in known_vulnerable:
            if check_package_vulnerability(package):
                # Would flag this for security review
                print(f"Potentially vulnerable package pattern detected: {package}")

    def test_license_compliance_check(self, project_root):
        """Test license compliance for security-related concerns."""
        try:
            # Validate Python executable for security
            if not sys.executable or not Path(sys.executable).is_file():
                pytest.skip("Python executable not found or invalid")

            # Use pip-licenses if available - explicitly construct command for security
            licenses_cmd = [sys.executable, "-m", "pip_licenses", "--format=json"]
            result = (
                subprocess.run(  # Secure: validated executable, no shell, no user input
                    licenses_cmd,
                    cwd=project_root,
                    capture_output=True,
                    text=True,
                    timeout=60,
                    check=False,
                )
            )

            if result.returncode == 0:
                licenses = json.loads(result.stdout)

                # Flag potentially problematic licenses for security review
                problematic_licenses = ["GPL", "AGPL", "SSPL"]

                flagged_packages = [
                    f"{package['Name']}: {license_name}"
                    for package in licenses
                    for problematic in problematic_licenses
                    if (license_name := package.get("License", ""))
                    and problematic in license_name.upper()
                ]

                if flagged_packages:
                    print(
                        f"Packages with licenses requiring review: {flagged_packages}"
                    )

        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            pytest.skip("pip-licenses tool not available")

    def test_outdated_package_detection(self, project_root):
        """Test detection of outdated packages with security implications."""
        try:
            # Validate Python executable for security
            if not sys.executable or not Path(sys.executable).is_file():
                pytest.skip("Python executable not found or invalid")

            # Check for outdated packages - explicitly construct command for security
            outdated_cmd = [
                sys.executable,
                "-m",
                "pip",
                "list",
                "--outdated",
                "--format=json",
            ]
            result = (
                subprocess.run(  # Secure: validated executable, no shell, no user input
                    outdated_cmd,
                    cwd=project_root,
                    capture_output=True,
                    text=True,
                    timeout=60,
                    check=False,
                )
            )

            if result.returncode == 0 and result.stdout.strip():
                outdated_packages = json.loads(result.stdout)

                # Flag security-critical packages that are outdated
                security_critical = [
                    "cryptography",
                    "openssl",
                    "requests",
                    "urllib3",
                    "django",
                    "flask",
                    "fastapi",
                    "jinja2",
                    "pillow",
                ]

                critical_outdated = [
                    f"{package['name']}: {package['version']} -> {package['latest']}"
                    for package in outdated_packages
                    if package["name"].lower() in security_critical
                ]

                if critical_outdated:
                    print(
                        f"Security-critical packages that need updates: {critical_outdated}"
                    )

        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            pytest.skip("pip list command not available")

    def test_supply_chain_security_checks(self):
        """Test supply chain security measures."""

        # Test package integrity verification
        def verify_package_integrity(_package_name: str, _expected_hash: str) -> bool:
            """Verify package integrity using checksums."""
            # In real implementation, this would verify package hashes
            # against known good values
            return True  # Placeholder

        # Test for typosquatting protection
        def check_typosquatting(package_name: str) -> list[str]:
            """Check for potential typosquatting packages."""
            suspicious_packages = []

            common_typos = {
                "requests": ["request", "requsts", "reqeusts"],
                "urllib3": ["urllib", "urlib3", "urllib2"],
                "django": ["djnago", "djangoo", "djang0"],
                "flask": ["falsk", "flsak", "flaskk"],
            }

            for legitimate, typos in common_typos.items():
                if package_name in typos:
                    suspicious_packages.append(
                        f"Possible typosquatting: {package_name} (legitimate: {legitimate})"
                    )

            return suspicious_packages

        # Test some packages
        test_packages = ["requests", "urllib3", "django", "flask"]

        for package in test_packages:
            # Verify integrity (placeholder)
            assert verify_package_integrity(package, "dummy_hash") is True

            # Check for typosquatting
            typo_issues = check_typosquatting(package)
            assert (
                len(typo_issues) == 0
            )  # Should not find typos for legitimate packages

    def test_vulnerability_remediation_tracking(self, mock_vulnerability_database):
        """Test vulnerability remediation tracking."""

        class VulnerabilityTracker:
            def __init__(self):
                self.known_vulnerabilities = {}
                self.remediation_status = {}

            def track_vulnerability(
                self, vuln_id: str, package: str, severity: str, status: str = "open"
            ):
                """Track vulnerability remediation status."""
                self.known_vulnerabilities[vuln_id] = {
                    "package": package,
                    "severity": severity,
                    "status": status,
                    "discovered_date": "2023-01-01",
                    "remediation_deadline": "2023-02-01"
                    if severity == "critical"
                    else "2023-03-01",
                }

            def get_overdue_vulnerabilities(
                self, current_date: str
            ) -> list[dict[str, Any]]:
                """Get vulnerabilities past their remediation deadline."""
                return [
                    vuln_data
                    for vuln_data in self.known_vulnerabilities.values()
                    if (
                        vuln_data["status"] == "open"
                        and current_date > vuln_data["remediation_deadline"]
                    )
                ]

        tracker = VulnerabilityTracker()

        # Track vulnerabilities from mock database
        for vuln in mock_vulnerability_database["vulnerabilities"]:
            tracker.track_vulnerability(vuln["id"], vuln["package"], vuln["severity"])

        # Check for overdue vulnerabilities
        overdue = tracker.get_overdue_vulnerabilities("2023-03-15")

        # Should have some overdue vulnerabilities in test data
        assert len(overdue) > 0

        # Critical vulnerabilities should be prioritized
        critical_overdue = [v for v in overdue if v["severity"] == "critical"]
        if critical_overdue:
            print(f"Critical vulnerabilities overdue: {len(critical_overdue)}")

    def test_automated_vulnerability_monitoring(self):
        """Test automated vulnerability monitoring setup."""

        class VulnerabilityMonitor:
            def __init__(self):
                self.monitoring_enabled = True
                self.notification_channels = ["email", "slack"]
                self.scan_frequency = "daily"

            def configure_monitoring(self, config: dict[str, Any]):
                """Configure vulnerability monitoring."""
                self.monitoring_enabled = config.get("enabled", True)
                self.notification_channels = config.get("channels", ["email"])
                self.scan_frequency = config.get("frequency", "daily")

            def should_alert(self, severity: str) -> bool:
                """Determine if vulnerability should trigger alert."""
                alert_severities = ["critical", "high"]
                return severity in alert_severities

        monitor = VulnerabilityMonitor()

        # Configure monitoring
        monitor.configure_monitoring(
            {
                "enabled": True,
                "channels": ["email", "slack", "jira"],
                "frequency": "daily",
            }
        )

        # Test alerting logic
        assert monitor.should_alert("critical") is True
        assert monitor.should_alert("high") is True
        assert monitor.should_alert("medium") is False
        assert monitor.should_alert("low") is False

        # Verify configuration
        assert monitor.monitoring_enabled is True
        assert "jira" in monitor.notification_channels
        assert monitor.scan_frequency == "daily"


@pytest.mark.security
@pytest.mark.integration
class TestRealSecurityIntegration:
    """Real security scanning integration tests."""

    @pytest.fixture
    def security_scanner_factory(self):
        """Factory for creating real security scanners."""

        class SecurityScannerFactory:
            def __init__(self):
                self.available_scanners = self._detect_available_scanners()

            def _detect_available_scanners(self) -> dict[str, bool]:
                """Detect which security scanners are available."""
                scanners = {}

                # Check for Safety
                try:
                    result = subprocess.run(
                        [sys.executable, "-m", "safety", "--version"],
                        capture_output=True,
                        timeout=10,
                        check=False,
                    )
                    scanners["safety"] = result.returncode == 0
                except (subprocess.SubprocessError, OSError, TimeoutError):
                    scanners["safety"] = False

                # Check for Bandit
                try:
                    result = subprocess.run(
                        [sys.executable, "-m", "bandit", "--version"],
                        capture_output=True,
                        timeout=10,
                        check=False,
                    )
                    scanners["bandit"] = result.returncode == 0
                except (subprocess.SubprocessError, OSError, TimeoutError):
                    scanners["bandit"] = False

                # Check for Semgrep
                try:
                    result = subprocess.run(
                        ["semgrep", "--version"],  # noqa: S607
                        capture_output=True,
                        timeout=10,
                        check=False,
                    )
                    scanners["semgrep"] = result.returncode == 0
                except (subprocess.SubprocessError, OSError, TimeoutError):
                    scanners["semgrep"] = False

                # Check for trivy
                try:
                    result = subprocess.run(
                        ["trivy", "--version"],  # noqa: S607
                        capture_output=True,
                        timeout=10,
                        check=False,
                    )
                    scanners["trivy"] = result.returncode == 0
                except (subprocess.SubprocessError, OSError, TimeoutError):
                    scanners["trivy"] = False

                return scanners

            def create_safety_scanner(self) -> "RealSafetyScanner":
                """Create real Safety vulnerability scanner."""
                if not self.available_scanners.get("safety", False):
                    pytest.skip("Safety scanner not available")

                return RealSafetyScanner()

            def create_bandit_scanner(self) -> "RealBanditScanner":
                """Create real Bandit security scanner."""
                if not self.available_scanners.get("bandit", False):
                    pytest.skip("Bandit scanner not available")

                return RealBanditScanner()

            def create_semgrep_scanner(self) -> "RealSemgrepScanner":
                """Create real Semgrep scanner."""
                if not self.available_scanners.get("semgrep", False):
                    pytest.skip("Semgrep scanner not available")

                return RealSemgrepScanner()

            def create_trivy_scanner(self) -> "RealTrivyScanner":
                """Create real Trivy scanner."""
                if not self.available_scanners.get("trivy", False):
                    pytest.skip("Trivy scanner not available")

                return RealTrivyScanner()

        return SecurityScannerFactory()

    def test_real_safety_vulnerability_scan(
        self, security_scanner_factory, project_root
    ):
        """Test real Safety vulnerability scanning."""
        safety_scanner = security_scanner_factory.create_safety_scanner()

        # Perform real vulnerability scan
        results = safety_scanner.scan_project(project_root)

        # Validate results structure
        assert isinstance(results, list)

        # Analyze results
        critical_vulns = [v for v in results if v.get("severity") == "critical"]
        high_vulns = [v for v in results if v.get("severity") == "high"]

        # Log findings
        if critical_vulns:
            print(f"CRITICAL: {len(critical_vulns)} critical vulnerabilities found")
            for vuln in critical_vulns[:3]:  # Show first 3
                print(
                    f"  - {vuln.get('package_name', 'Unknown')}: {vuln.get('vulnerability_id', 'Unknown')}"
                )

        if high_vulns:
            print(f"HIGH: {len(high_vulns)} high severity vulnerabilities found")

        # Security policy: Fail if too many critical vulnerabilities
        assert len(critical_vulns) <= 5, (
            f"Too many critical vulnerabilities: {len(critical_vulns)}"
        )

    def test_real_bandit_code_security_scan(
        self, security_scanner_factory, project_root
    ):
        """Test real Bandit code security scanning."""
        bandit_scanner = security_scanner_factory.create_bandit_scanner()

        # Perform real code security scan
        results = bandit_scanner.scan_project(project_root)

        # Validate results structure
        assert "results" in results
        assert "metrics" in results

        # Analyze security issues
        issues = results["results"]
        high_severity_issues = [
            issue for issue in issues if issue.get("issue_severity") == "HIGH"
        ]

        # Log findings
        if high_severity_issues:
            print(
                f"HIGH SEVERITY: {len(high_severity_issues)} high severity security issues found"
            )
            for issue in high_severity_issues[:3]:  # Show first 3
                print(
                    f"  - {issue.get('filename', 'Unknown')}:{issue.get('line_number', '?')}"
                )
                print(f"    {issue.get('issue_text', 'No description')}")

        # Security policy: Fail if too many high severity issues
        assert len(high_severity_issues) <= 10, (
            f"Too many high severity security issues: {len(high_severity_issues)}"
        )

    def test_real_semgrep_security_scan(self, security_scanner_factory, project_root):
        """Test real Semgrep security scanning."""
        semgrep_scanner = security_scanner_factory.create_semgrep_scanner()

        # Perform real Semgrep scan
        results = semgrep_scanner.scan_project(project_root)

        # Validate results
        assert isinstance(results, dict)
        assert "results" in results

        findings = results["results"]
        security_findings = [
            f for f in findings if "security" in f.get("check_id", "").lower()
        ]

        # Log security findings
        if security_findings:
            print(f"SEMGREP: {len(security_findings)} security findings")
            for finding in security_findings[:3]:
                print(
                    f"  - {finding.get('path', 'Unknown')}:{finding.get('start', {}).get('line', '?')}"
                )
                print(f"    {finding.get('message', 'No message')}")

    def test_real_trivy_container_scan(self, security_scanner_factory, project_root):
        """Test real Trivy container/dependency scanning."""
        trivy_scanner = security_scanner_factory.create_trivy_scanner()

        # Perform real Trivy scan
        results = trivy_scanner.scan_project(project_root)

        # Validate results
        assert isinstance(results, dict)

        if "Results" in results:
            for result in results["Results"]:
                vulnerabilities = result.get("Vulnerabilities", [])
                critical_vulns = [
                    v for v in vulnerabilities if v.get("Severity") == "CRITICAL"
                ]

                if critical_vulns:
                    print(
                        f"TRIVY CRITICAL: {len(critical_vulns)} critical vulnerabilities in {result.get('Target', 'Unknown')}"
                    )

    def test_comprehensive_security_audit(self, security_scanner_factory, project_root):
        """Comprehensive security audit using multiple real scanners."""
        audit_results = {
            "timestamp": datetime.now(UTC).isoformat(),
            "scanners": {},
            "summary": {"total_issues": 0, "critical_issues": 0, "high_issues": 0},
        }

        # Run all available scanners
        available_scanners = security_scanner_factory.available_scanners

        for scanner_name, available in available_scanners.items():
            if available:
                try:
                    if scanner_name == "safety":
                        scanner = security_scanner_factory.create_safety_scanner()
                        results = scanner.scan_project(project_root)
                        audit_results["scanners"]["safety"] = {
                            "vulnerabilities": len(results),
                            "critical": len(
                                [v for v in results if v.get("severity") == "critical"]
                            ),
                            "high": len(
                                [v for v in results if v.get("severity") == "high"]
                            ),
                        }

                    elif scanner_name == "bandit":
                        scanner = security_scanner_factory.create_bandit_scanner()
                        results = scanner.scan_project(project_root)
                        issues = results.get("results", [])
                        audit_results["scanners"]["bandit"] = {
                            "total_issues": len(issues),
                            "high_severity": len(
                                [i for i in issues if i.get("issue_severity") == "HIGH"]
                            ),
                            "medium_severity": len(
                                [
                                    i
                                    for i in issues
                                    if i.get("issue_severity") == "MEDIUM"
                                ]
                            ),
                        }

                    elif scanner_name == "semgrep":
                        scanner = security_scanner_factory.create_semgrep_scanner()
                        results = scanner.scan_project(project_root)
                        findings = results.get("results", [])
                        security_findings = [
                            f
                            for f in findings
                            if "security" in f.get("check_id", "").lower()
                        ]
                        audit_results["scanners"]["semgrep"] = {
                            "total_findings": len(findings),
                            "security_findings": len(security_findings),
                        }

                    elif scanner_name == "trivy":
                        scanner = security_scanner_factory.create_trivy_scanner()
                        results = scanner.scan_project(project_root)
                        total_vulns = 0
                        critical_vulns = 0

                        for result in results.get("Results", []):
                            vulns = result.get("Vulnerabilities", [])
                            total_vulns += len(vulns)
                            critical_vulns += len(
                                [v for v in vulns if v.get("Severity") == "CRITICAL"]
                            )

                        audit_results["scanners"]["trivy"] = {
                            "total_vulnerabilities": total_vulns,
                            "critical_vulnerabilities": critical_vulns,
                        }

                except (RuntimeError, ValueError, TypeError) as e:
                    print(f"Scanner {scanner_name} failed: {e}")
                    audit_results["scanners"][scanner_name] = {"error": str(e)}

        # Calculate summary
        for scanner_data in audit_results["scanners"].values():
            if "error" not in scanner_data:
                # Aggregate issues across scanners
                audit_results["summary"]["total_issues"] += scanner_data.get(
                    "vulnerabilities", 0
                )
                audit_results["summary"]["total_issues"] += scanner_data.get(
                    "total_issues", 0
                )
                audit_results["summary"]["total_issues"] += scanner_data.get(
                    "total_findings", 0
                )
                audit_results["summary"]["total_issues"] += scanner_data.get(
                    "total_vulnerabilities", 0
                )

                audit_results["summary"]["critical_issues"] += scanner_data.get(
                    "critical", 0
                )
                audit_results["summary"]["critical_issues"] += scanner_data.get(
                    "critical_vulnerabilities", 0
                )

                audit_results["summary"]["high_issues"] += scanner_data.get("high", 0)
                audit_results["summary"]["high_issues"] += scanner_data.get(
                    "high_severity", 0
                )

        # Save audit results
        audit_file = project_root / ".security-audit-results.json"
        with audit_file.open("w") as f:
            json.dump(audit_results, f, indent=2)

        print(f"Security audit complete: {audit_results['summary']}")

        # Assert reasonable security posture
        assert audit_results["summary"]["critical_issues"] <= 10, (
            f"Too many critical security issues: {audit_results['summary']['critical_issues']}"
        )


class RealSafetyScanner:
    """Real Safety vulnerability scanner integration."""

    def scan_project(self, project_root: Path) -> list[dict]:
        """Scan project using real Safety tool."""
        vulnerabilities = []

        # Find requirements files
        req_files = [
            project_root / "requirements.txt",
            project_root / "requirements-dev.txt",
            project_root / "pyproject.toml",
        ]

        for req_file in req_files:
            if req_file.exists():
                try:
                    cmd = [
                        sys.executable,
                        "-m",
                        "safety",
                        "check",
                        "--json",
                        "--file",
                        str(req_file),
                    ]
                    result = subprocess.run(
                        cmd,
                        cwd=project_root,
                        capture_output=True,
                        text=True,
                        timeout=120,
                        check=False,
                    )

                    if result.stdout:
                        try:
                            safety_data = json.loads(result.stdout)
                            if isinstance(safety_data, list):
                                vulnerabilities.extend(safety_data)
                        except json.JSONDecodeError:
                            # Safety may output non-JSON in some cases
                            pass

                except (json.JSONDecodeError, ValueError, TypeError) as e:
                    print(f"Safety scan failed for {req_file}: {e}")

        return vulnerabilities


class RealBanditScanner:
    """Real Bandit security scanner integration."""

    def scan_project(self, project_root: Path) -> dict:
        """Scan project using real Bandit tool."""
        try:
            cmd = [
                sys.executable,
                "-m",
                "bandit",
                "-r",
                "src/",  # Scan source directory
                "-f",
                "json",
                "--skip",
                "B101,B601",  # Skip common false positives
            ]

            result = subprocess.run(
                cmd,
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=180,
                check=False,
            )

            if result.stdout:
                return json.loads(result.stdout)

        except (json.JSONDecodeError, ValueError, TypeError) as e:
            print(f"Bandit scan failed: {e}")
            return {"results": [], "metrics": {}, "error": str(e)}
        else:
            return {"results": [], "metrics": {}}


class RealSemgrepScanner:
    """Real Semgrep security scanner integration."""

    def scan_project(self, project_root: Path) -> dict:
        """Scan project using real Semgrep tool."""
        try:
            cmd = [
                "semgrep",
                "--config=auto",  # Use Semgrep's default security rules
                "--json",
                "--timeout=120",
                "src/",  # Scan source directory
            ]

            result = subprocess.run(
                cmd,
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=300,
                check=False,
            )

            if result.stdout:
                return json.loads(result.stdout)

        except (json.JSONDecodeError, ValueError, TypeError) as e:
            print(f"Semgrep scan failed: {e}")
            return {"results": [], "error": str(e)}
        else:
            return {"results": []}


class RealTrivyScanner:
    """Real Trivy vulnerability scanner integration."""

    def scan_project(self, project_root: Path) -> dict:
        """Scan project using real Trivy tool."""
        try:
            cmd = [
                "trivy",
                "fs",  # Filesystem scan
                "--format",
                "json",
                "--security-checks",
                "vuln,secret,config",
                str(project_root),
            ]

            result = subprocess.run(
                cmd,
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=300,
                check=False,
            )

            if result.stdout:
                return json.loads(result.stdout)

        except (json.JSONDecodeError, ValueError, TypeError) as e:
            print(f"Trivy scan failed: {e}")
            return {"Results": [], "error": str(e)}
        else:
            return {"Results": []}

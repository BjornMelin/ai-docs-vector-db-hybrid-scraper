"""Dependency vulnerability scanning tests.

This module tests automated vulnerability scanning of project dependencies
using tools like Safety and Bandit.
"""

import json
import subprocess
import sys
from pathlib import Path
from typing import Any

import pytest


@pytest.mark.security
@pytest.mark.vulnerability
class TestDependencyScanning:
    """Test dependency vulnerability scanning."""

    @pytest.fixture
    def project_root(self):
        """Get project root directory."""
        return Path(__file__).parent.parent.parent.parent

    @pytest.fixture
    def requirements_files(self, project_root):
        """Get requirements files."""
        return {
            "requirements.txt": project_root / "requirements.txt",
            "requirements-dev.txt": project_root / "requirements-dev.txt",
            "pyproject.toml": project_root / "pyproject.toml",
        }

    @pytest.fixture
    def mock_vulnerability_database(self):
        """Mock vulnerability database for testing."""
        return {
            "vulnerabilities": [
                {
                    "id": "CVE-2023-0001",
                    "package": "vulnerable-package",
                    "versions": ["<1.2.3"],
                    "severity": "high",
                    "description": "SQL injection vulnerability",
                    "cwe": "CWE-89",
                    "cvss_score": 8.5,
                    "fixed_in": "1.2.3",
                },
                {
                    "id": "CVE-2023-0002",
                    "package": "another-vulnerable-package",
                    "versions": [">=1.0.0,<2.1.0"],
                    "severity": "medium",
                    "description": "Cross-site scripting vulnerability",
                    "cwe": "CWE-79",
                    "cvss_score": 6.1,
                    "fixed_in": "2.1.0",
                },
                {
                    "id": "CVE-2023-0003",
                    "package": "insecure-crypto",
                    "versions": ["<=3.0.0"],
                    "severity": "critical",
                    "description": "Weak cryptographic implementation",
                    "cwe": "CWE-327",
                    "cvss_score": 9.8,
                    "fixed_in": "3.1.0",
                },
            ]
        }

    @pytest.fixture
    def safety_scanner(self, mock_vulnerability_database):
        """Mock Safety vulnerability scanner."""

        class SafetyScanner:
            def __init__(self, vuln_db):
                self.vuln_db = vuln_db

            def scan_requirements(self, requirements_file: str) -> list[dict[str, Any]]:
                """Scan requirements file for vulnerabilities."""
                # Parse requirements file (simplified)
                packages = self._parse_requirements(requirements_file)
                vulnerabilities = []

                for package_name, version in packages.items():
                    for vuln in self.vuln_db["vulnerabilities"]:
                        if vuln["package"] == package_name:
                            if self._version_is_vulnerable(version, vuln["versions"]):
                                vulnerabilities.append(
                                    {
                                        "package": package_name,
                                        "installed_version": version,
                                        "vulnerability": vuln,
                                    }
                                )

                return vulnerabilities

            def _parse_requirements(self, _requirements_file: str) -> dict[str, str]:
                """Parse requirements file (simplified)."""
                # This would parse actual requirements in real implementation
                return {
                    "vulnerable-package": "1.2.0",  # Vulnerable version
                    "safe-package": "2.0.0",
                    "another-vulnerable-package": "1.5.0",  # Vulnerable version
                }

            def _version_is_vulnerable(
                self, version: str, vulnerable_versions: list[str]
            ) -> bool:
                """Check if version is vulnerable (simplified)."""
                # Simplified version checking - real implementation would use packaging.version
                for vuln_version in vulnerable_versions:
                    if "<" in vuln_version:
                        max_version = vuln_version.replace("<", "")
                        if version < max_version:
                            return True
                    elif "=" in vuln_version and "," in vuln_version:
                        # Range check (simplified)
                        return True
                return False

        return SafetyScanner(mock_vulnerability_database)

    @pytest.fixture
    def bandit_scanner(self):
        """Mock Bandit security scanner."""

        class BanditScanner:
            def __init__(self):
                self.test_results = []

            def scan_code(self, _source_paths: list[str]) -> dict[str, Any]:
                """Scan source code for security issues."""
                return {
                    "results": [
                        {
                            "filename": "src/example.py",
                            "test_name": "hardcoded_password_string",
                            "test_id": "B106",
                            "issue_severity": "LOW",
                            "issue_confidence": "MEDIUM",
                            "line_number": 45,
                            "line_range": [45],
                            "code": "password = 'hardcoded_secret'",
                            "issue_text": "Possible hardcoded password: 'hardcoded_secret'",
                        },
                        {
                            "filename": "src/database.py",
                            "test_name": "sql_injection_risk",
                            "test_id": "B608",
                            "issue_severity": "HIGH",
                            "issue_confidence": "HIGH",
                            "line_number": 123,
                            "line_range": [123, 124],
                            "code": "cursor.execute(f'SELECT * FROM users WHERE id = {user_id}')",
                            "issue_text": "Possible SQL injection vector through string-based query construction",
                        },
                    ],
                    "metrics": {
                        "_totals": {
                            "SEVERITY.HIGH": 1,
                            "SEVERITY.MEDIUM": 0,
                            "SEVERITY.LOW": 1,
                            "CONFIDENCE.HIGH": 1,
                            "CONFIDENCE.MEDIUM": 1,
                            "CONFIDENCE.LOW": 0,
                        }
                    },
                }

        return BanditScanner()

    def test_safety_dependency_scan(self, safety_scanner):
        """Test Safety dependency vulnerability scanning."""
        vulnerabilities = safety_scanner.scan_requirements("requirements.txt")

        # Should find vulnerabilities in test data
        assert len(vulnerabilities) > 0

        # Check vulnerability structure
        for vuln in vulnerabilities:
            assert "package" in vuln
            assert "installed_version" in vuln
            assert "vulnerability" in vuln
            assert "id" in vuln["vulnerability"]
            assert "severity" in vuln["vulnerability"]
            assert "description" in vuln["vulnerability"]

    def test_safety_critical_vulnerability_detection(self, safety_scanner):
        """Test detection of critical vulnerabilities."""
        vulnerabilities = safety_scanner.scan_requirements("requirements.txt")

        critical_vulns = [
            v for v in vulnerabilities if v["vulnerability"]["severity"] == "critical"
        ]

        # Should detect critical vulnerabilities
        assert len(critical_vulns) > 0

        for vuln in critical_vulns:
            assert vuln["vulnerability"]["cvss_score"] >= 9.0

    def test_safety_high_severity_vulnerability_detection(self, safety_scanner):
        """Test detection of high severity vulnerabilities."""
        vulnerabilities = safety_scanner.scan_requirements("requirements.txt")

        high_severity_vulns = [
            v
            for v in vulnerabilities
            if v["vulnerability"]["severity"] in ["high", "critical"]
        ]

        # Should detect high severity vulnerabilities
        assert len(high_severity_vulns) > 0

        for vuln in high_severity_vulns:
            assert vuln["vulnerability"]["cvss_score"] >= 7.0

    def test_bandit_code_security_scan(self, bandit_scanner):
        """Test Bandit code security scanning."""
        scan_results = bandit_scanner.scan_code(["src/"])

        # Should have scan results
        assert "results" in scan_results
        assert "metrics" in scan_results

        # Check for security issues
        results = scan_results["results"]
        assert len(results) > 0

        # Verify issue structure
        for issue in results:
            assert "filename" in issue
            assert "test_name" in issue
            assert "test_id" in issue
            assert "issue_severity" in issue
            assert "issue_confidence" in issue
            assert "line_number" in issue
            assert "code" in issue
            assert "issue_text" in issue

    def test_bandit_high_severity_detection(self, bandit_scanner):
        """Test Bandit detection of high severity issues."""
        scan_results = bandit_scanner.scan_code(["src/"])

        high_severity_issues = [
            issue
            for issue in scan_results["results"]
            if issue["issue_severity"] == "HIGH"
        ]

        # Should detect high severity issues
        assert len(high_severity_issues) > 0

        for issue in high_severity_issues:
            assert issue["issue_confidence"] in ["HIGH", "MEDIUM"]

    def test_vulnerability_scan_integration(self, project_root):
        """Test integration with actual vulnerability scanning tools."""
        # Skip if tools are not available
        try:
            # Test Safety
            result = subprocess.run(
                [sys.executable, "-m", "safety", "check", "--json"],
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=60,
                check=False,
            )

            if result.returncode == 0:
                # No vulnerabilities found (good)
                assert True
            else:
                # Vulnerabilities found - parse and validate
                try:
                    safety_output = json.loads(result.stdout)
                    # Safety found vulnerabilities - this is a test environment concern
                    assert isinstance(safety_output, list)
                except json.JSONDecodeError:
                    # Safety may output non-JSON format in some versions
                    pass

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pytest.skip("Safety tool not available or timed out")

    def test_bandit_integration(self, project_root):
        """Test integration with actual Bandit scanning."""
        try:
            # Test Bandit
            result = subprocess.run(
                [sys.executable, "-m", "bandit", "-r", "src/", "-f", "json"],
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=120,
                check=False,
            )

            # Bandit returns non-zero exit code when issues are found
            if result.stdout:
                try:
                    bandit_output = json.loads(result.stdout)
                    assert "results" in bandit_output
                    assert "metrics" in bandit_output

                    # Check for any HIGH severity issues
                    high_issues = [
                        issue
                        for issue in bandit_output["results"]
                        if issue.get("issue_severity") == "HIGH"
                    ]

                    # Log any high severity issues for review
                    if high_issues:
                        print(f"Found {len(high_issues)} high severity security issues")
                        for issue in high_issues:
                            print(
                                f"  {issue['filename']}:{issue['line_number']} - {issue['issue_text']}"
                            )

                except json.JSONDecodeError:
                    pytest.skip("Bandit output format not parseable")

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pytest.skip("Bandit tool not available or timed out")

    def test_dependency_pinning_security(self, requirements_files):
        """Test that dependencies are properly pinned for security."""
        for req_file_name, req_file_path in requirements_files.items():
            if req_file_path.exists():
                with open(req_file_path) as f:
                    content = f.read()

                if req_file_name.endswith(".txt"):
                    lines = [
                        line.strip()
                        for line in content.split("\n")
                        if line.strip() and not line.startswith("#")
                    ]

                    unpinned_packages = []
                    for line in lines:
                        if "==" not in line and ">=" not in line and "~=" not in line:
                            # Package is not pinned
                            unpinned_packages.append(line)

                    # Allow some flexibility but warn about completely unpinned packages
                    if unpinned_packages:
                        print(
                            f"Warning: Unpinned packages in {req_file_name}: {unpinned_packages}"
                        )

    def test_known_vulnerable_packages(self):
        """Test detection of known vulnerable packages."""
        known_vulnerable = [
            "jinja2<2.11.3",  # CVE-2020-28493
            "pillow<8.1.1",  # Multiple CVEs
            "django<3.1.6",  # CVE-2021-3281
            "flask<2.0.0",  # Multiple security issues
            "requests<2.25.0",  # CVE-2021-33503
        ]

        # In a real test, this would check actual installed packages
        # For demo purposes, we'll simulate the check
        def check_package_vulnerability(package_spec: str) -> bool:
            """Check if package specification represents a vulnerable version."""
            # This would integrate with actual vulnerability databases
            package_name = package_spec.split("<")[0]
            return package_name in ["jinja2", "pillow", "django", "flask", "requests"]

        for package in known_vulnerable:
            if check_package_vulnerability(package):
                # Would flag this for security review
                print(f"Potentially vulnerable package pattern detected: {package}")

    def test_license_compliance_check(self, project_root):
        """Test license compliance for security-related concerns."""
        try:
            # Use pip-licenses if available
            result = subprocess.run(
                [sys.executable, "-m", "pip_licenses", "--format=json"],
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=60,
                check=False,
            )

            if result.returncode == 0:
                licenses = json.loads(result.stdout)

                # Flag potentially problematic licenses for security review
                problematic_licenses = ["GPL", "AGPL", "SSPL"]

                flagged_packages = []
                for package in licenses:
                    license_name = package.get("License", "")
                    for problematic in problematic_licenses:
                        if problematic in license_name.upper():
                            flagged_packages.append(
                                f"{package['Name']}: {license_name}"
                            )

                if flagged_packages:
                    print(
                        f"Packages with licenses requiring review: {flagged_packages}"
                    )

        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            pytest.skip("pip-licenses tool not available")

    def test_outdated_package_detection(self, project_root):
        """Test detection of outdated packages with security implications."""
        try:
            # Check for outdated packages
            result = subprocess.run(
                [sys.executable, "-m", "pip", "list", "--outdated", "--format=json"],
                cwd=project_root,
                capture_output=True,
                text=True,
                timeout=60,
                check=False,
            )

            if result.returncode == 0 and result.stdout.strip():
                outdated_packages = json.loads(result.stdout)

                # Flag security-critical packages that are outdated
                security_critical = [
                    "cryptography",
                    "openssl",
                    "requests",
                    "urllib3",
                    "django",
                    "flask",
                    "fastapi",
                    "jinja2",
                    "pillow",
                ]

                critical_outdated = []
                for package in outdated_packages:
                    if package["name"].lower() in security_critical:
                        critical_outdated.append(
                            f"{package['name']}: {package['version']} -> {package['latest']}"
                        )

                if critical_outdated:
                    print(
                        f"Security-critical packages that need updates: {critical_outdated}"
                    )

        except (subprocess.TimeoutExpired, FileNotFoundError, json.JSONDecodeError):
            pytest.skip("pip list command not available")

    def test_supply_chain_security_checks(self):
        """Test supply chain security measures."""

        # Test package integrity verification
        def verify_package_integrity(_package_name: str, _expected_hash: str) -> bool:
            """Verify package integrity using checksums."""
            # In real implementation, this would verify package hashes
            # against known good values
            return True  # Placeholder

        # Test for typosquatting protection
        def check_typosquatting(package_name: str) -> list[str]:
            """Check for potential typosquatting packages."""
            suspicious_packages = []

            common_typos = {
                "requests": ["request", "requsts", "reqeusts"],
                "urllib3": ["urllib", "urlib3", "urllib2"],
                "django": ["djnago", "djangoo", "djang0"],
                "flask": ["falsk", "flsak", "flaskk"],
            }

            for legitimate, typos in common_typos.items():
                if package_name in typos:
                    suspicious_packages.append(
                        f"Possible typosquatting: {package_name} (legitimate: {legitimate})"
                    )

            return suspicious_packages

        # Test some packages
        test_packages = ["requests", "urllib3", "django", "flask"]

        for package in test_packages:
            # Verify integrity (placeholder)
            assert verify_package_integrity(package, "dummy_hash") is True

            # Check for typosquatting
            typo_issues = check_typosquatting(package)
            assert (
                len(typo_issues) == 0
            )  # Should not find typos for legitimate packages

    def test_vulnerability_remediation_tracking(self, mock_vulnerability_database):
        """Test vulnerability remediation tracking."""

        class VulnerabilityTracker:
            def __init__(self):
                self.known_vulnerabilities = {}
                self.remediation_status = {}

            def track_vulnerability(
                self, vuln_id: str, package: str, severity: str, status: str = "open"
            ):
                """Track vulnerability remediation status."""
                self.known_vulnerabilities[vuln_id] = {
                    "package": package,
                    "severity": severity,
                    "status": status,
                    "discovered_date": "2023-01-01",
                    "remediation_deadline": "2023-02-01"
                    if severity == "critical"
                    else "2023-03-01",
                }

            def get_overdue_vulnerabilities(
                self, current_date: str
            ) -> list[dict[str, Any]]:
                """Get vulnerabilities past their remediation deadline."""
                overdue = []
                for vuln_data in self.known_vulnerabilities.values():
                    if (
                        vuln_data["status"] == "open"
                        and current_date > vuln_data["remediation_deadline"]
                    ):
                        overdue.append(vuln_data)
                return overdue

        tracker = VulnerabilityTracker()

        # Track vulnerabilities from mock database
        for vuln in mock_vulnerability_database["vulnerabilities"]:
            tracker.track_vulnerability(vuln["id"], vuln["package"], vuln["severity"])

        # Check for overdue vulnerabilities
        overdue = tracker.get_overdue_vulnerabilities("2023-03-15")

        # Should have some overdue vulnerabilities in test data
        assert len(overdue) > 0

        # Critical vulnerabilities should be prioritized
        critical_overdue = [v for v in overdue if v["severity"] == "critical"]
        if critical_overdue:
            print(f"Critical vulnerabilities overdue: {len(critical_overdue)}")

    def test_automated_vulnerability_monitoring(self):
        """Test automated vulnerability monitoring setup."""

        class VulnerabilityMonitor:
            def __init__(self):
                self.monitoring_enabled = True
                self.notification_channels = ["email", "slack"]
                self.scan_frequency = "daily"

            def configure_monitoring(self, config: dict[str, Any]):
                """Configure vulnerability monitoring."""
                self.monitoring_enabled = config.get("enabled", True)
                self.notification_channels = config.get("channels", ["email"])
                self.scan_frequency = config.get("frequency", "daily")

            def should_alert(self, severity: str) -> bool:
                """Determine if vulnerability should trigger alert."""
                alert_severities = ["critical", "high"]
                return severity in alert_severities

        monitor = VulnerabilityMonitor()

        # Configure monitoring
        monitor.configure_monitoring(
            {
                "enabled": True,
                "channels": ["email", "slack", "jira"],
                "frequency": "daily",
            }
        )

        # Test alerting logic
        assert monitor.should_alert("critical") is True
        assert monitor.should_alert("high") is True
        assert monitor.should_alert("medium") is False
        assert monitor.should_alert("low") is False

        # Verify configuration
        assert monitor.monitoring_enabled is True
        assert "jira" in monitor.notification_channels
        assert monitor.scan_frequency == "daily"

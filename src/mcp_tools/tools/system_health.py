"""MCP tools for querying centralized system health state."""

from __future__ import annotations

import gc
import logging
from typing import Any

from fastmcp import Context

from src.services.observability.health_manager import (
    HealthCheckManager,
    HealthStatus,
)


try:  # pragma: no cover - optional dependency
    import psutil  # type: ignore[import-not-found]
except ImportError:  # pragma: no cover - optional dependency
    psutil = None  # type: ignore[assignment]


logger = logging.getLogger(__name__)


def _bytes_to_mb(value: float | int) -> float:
    """Convert raw byte counts to mebibytes."""
    return float(value) / (1024 * 1024)


def _collect_resource_snapshot() -> dict[str, Any]:
    """Collect process and system resource utilisation statistics."""
    if psutil is None:
        return {"psutil_available": False}

    snapshot: dict[str, Any] = {"psutil_available": True}

    try:
        process = psutil.Process()
        with process.oneshot():
            memory_info = process.memory_info()
            snapshot["process"] = {
                "cpu_percent": process.cpu_percent(interval=None),
                "memory_percent": process.memory_percent(),
                "rss_memory_mb": _bytes_to_mb(memory_info.rss),
                "num_threads": process.num_threads(),
                "open_file_count": len(process.open_files()),
                "connection_count": len(process.net_connections(kind="inet")),
            }
    except (psutil.Error, OSError):  # pragma: no cover - best effort only
        logger.debug("Failed to collect process metrics", exc_info=True)

    try:
        virtual_memory = psutil.virtual_memory()
        swap = psutil.swap_memory()
        disk_usage = psutil.disk_usage("/")
        snapshot["system"] = {
            "cpu_count_logical": psutil.cpu_count(logical=True),
            "memory_total_mb": _bytes_to_mb(virtual_memory.total),
            "memory_available_mb": _bytes_to_mb(virtual_memory.available),
            "memory_usage_percent": virtual_memory.percent,
            "swap_usage_percent": swap.percent,
            "disk_usage_percent": disk_usage.percent,
            "disk_total_gb": disk_usage.total / (1024**3),
            "disk_free_gb": disk_usage.free / (1024**3),
        }
    except (psutil.Error, OSError):  # pragma: no cover - best effort only
        logger.debug("Failed to collect system metrics", exc_info=True)

    try:
        disk_io = psutil.disk_io_counters()
        net_io = psutil.net_io_counters()
        if disk_io is not None and net_io is not None:
            snapshot["io"] = {
                "disk_read_mb": _bytes_to_mb(disk_io.read_bytes),
                "disk_write_mb": _bytes_to_mb(disk_io.write_bytes),
                "net_sent_mb": _bytes_to_mb(net_io.bytes_sent),
                "net_received_mb": _bytes_to_mb(net_io.bytes_recv),
            }
    except (psutil.Error, OSError):  # pragma: no cover - best effort only
        logger.debug("Failed to collect IO counters", exc_info=True)

    gc_stats: dict[str, Any] = {"counts": list(gc.get_count())}
    get_stats = getattr(gc, "get_stats", None)
    if callable(get_stats):
        raw_stats = get_stats()
        generation_stats: list[dict[str, int | None]] = []
        if isinstance(raw_stats, list):
            for stat in raw_stats:
                if isinstance(stat, dict):
                    generation_stats.append(
                        {
                            "collections": stat.get("collections"),
                            "collected": stat.get("collected"),
                            "uncollectable": stat.get("uncollectable"),
                        }
                    )
        if generation_stats:
            gc_stats["generations"] = generation_stats
    snapshot["garbage_collector"] = gc_stats

    return snapshot


def register_tools(
    mcp,
    *,
    health_manager: HealthCheckManager,
) -> None:
    """Register system health monitoring tools."""

    @mcp.tool()
    async def get_system_health(
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Return overall health information from the central manager.

        Args:
            ctx: Optional MCP context for streaming updates.

        Returns:
            Aggregated health summary generated by :class:`HealthCheckManager`.
        """
        summary = await health_manager.get_overall_health()

        if ctx:
            await ctx.info(f"System health: {summary['overall_status']}")

        return summary

    @mcp.tool()
    async def get_process_info(
        ctx: Context | None = None,
    ) -> dict[str, Any]:
        """Return the latest system resource check metadata.

        Args:
            ctx: Optional MCP context for streaming updates.

        Returns:
            Structured metadata for the ``system_resources`` health check.
        """
        result = await health_manager.check_single("system_resources")
        if result is None:
            message = (
                "System resource health check is not registered; "
                "enable monitoring to collect metrics."
            )
            if ctx:
                await ctx.info(message)
            return {"status": HealthStatus.UNKNOWN.value, "message": message}

        resource_snapshot = _collect_resource_snapshot()
        combined_metrics = dict(result.metadata)
        process_metrics = resource_snapshot.get("process", {})
        for key in ("cpu_percent", "memory_percent", "rss_memory_mb"):
            value = process_metrics.get(key)
            if key not in combined_metrics and value is not None:
                combined_metrics[key] = value

        response = {
            "status": result.status.value,
            "message": result.message,
            "timestamp": result.timestamp,
            "duration_ms": result.duration_ms,
            "metrics": combined_metrics,
            "resource_snapshot": resource_snapshot,
        }

        if ctx:
            cpu_usage = combined_metrics.get("cpu_percent", 0.0)
            memory_usage = combined_metrics.get("memory_percent", 0.0)
            await ctx.info(
                f"System resources {result.status.value}: "
                f"CPU {cpu_usage:.1f}%, memory {memory_usage:.1f}%"
            )

        return response

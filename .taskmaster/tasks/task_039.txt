# Task ID: 39
# Title: Function-Based Multi-Agent Core
# Status: pending
# Dependencies: 38
# Priority: high
# Description: Implement lightweight async multi-agent orchestration using semaphores & @lru_cache pools (2-10 agents).
# Details:
1. Core file `src/browser_use/agents.py`:
   ```py
   _AGENT_LIMIT = Semaphore(cfg.max_agents)
   @lru_cache
   def _profile_template():
       return BrowserProfile(...)
   async def get_agent() -> AsyncIterator[BrowserSession]:
       async with _AGENT_LIMIT:
           session = BrowserSession(browser_profile=_profile_template())
           await session.start();
           try:  yield session
           finally: await session.close()
   ```
2. Add adaptive scaler: if queue length > agents*0.8 increase max_agents (≤cfg.max_agents).
3. Health probe: `agent_health()` returns JSON of active_count, failures.
4. Resource tracking via `tracemalloc` snapshots every 60s.
5. Align error propagation with task 41.
6. Avoid class hierarchies; keep pure functions.

# Test Strategy:
• Async pytest: spin 10 concurrent `get_agent()` calls – all succeed <2s.
• Stress test with 1k URLs – measure 3× throughput over single agent.
• Memory baseline vs peak ≤1.5×.
• Race-condition test: ensure semaphore never exceeds limit.

# Subtasks:
## 1. Implement Async Multi-Agent Orchestration Core [pending]
### Dependencies: None
### Description: Develop the core async orchestration logic for managing 2-10 lightweight agents using semaphores and @lru_cache pools, ensuring pure function design and no class hierarchies.
### Details:
Create or refactor `src/browser_use/agents.py` to use a semaphore for agent concurrency limits and an @lru_cache for browser profile pooling. Ensure each agent session is managed asynchronously and resources are properly acquired and released.

## 2. Add Adaptive Agent Scaler [pending]
### Dependencies: 39.1
### Description: Implement logic to dynamically adjust the maximum number of concurrent agents based on queue length, scaling up when demand exceeds 80% of current capacity, but never exceeding cfg.max_agents.
### Details:
Monitor the agent request queue and increase the semaphore limit if the queue length surpasses 0.8 times the current agent count, up to the configured maximum. Ensure thread-safe updates and integration with the core orchestration logic.

## 3. Implement Agent Health Probe and Resource Tracking [pending]
### Dependencies: 39.1
### Description: Create a health probe function returning JSON with active agent count and failure statistics, and integrate periodic resource tracking using tracemalloc snapshots every 60 seconds.
### Details:
Expose an async function `agent_health()` that reports the number of active agents and recent failures. Set up a background task to capture and log tracemalloc memory snapshots at regular intervals for monitoring.

## 4. Align Error Propagation with Task 41 [pending]
### Dependencies: 39.1
### Description: Ensure all error handling and propagation in the orchestration core matches the conventions and requirements defined in Task 41.
### Details:
Review error handling in agent acquisition, scaling, and health probe logic. Refactor as needed to align with Task 41's error propagation strategy, ensuring consistent and predictable error reporting.

